<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>yasakura</title>
    <link>https://yasakura.me/</link>
    <description>Recent content on yasakura</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 02 Jan 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://yasakura.me/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to manage Python2.X, 3.X and packages every project</title>
      <link>https://yasakura.me/post/manage-python3-and-python27-and-packages-en/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yasakura.me/post/manage-python3-and-python27-and-packages-en/</guid>
      <description>Motivation  want to switch major version of Python (i.e. between Python2.X and Python3.X). want to switch minor version of Python (i.e. between Python3.A and Python3.B). want to isolate some packages for every project. don&amp;rsquo;t want to construct in vain a new docker container for each Python project.  How to switch any version of Python with pyenv Installation  Confirm the default Python version.
$ python --version Python 2.</description>
    </item>
    
    <item>
      <title>サイトポリシー</title>
      <link>https://yasakura.me/terms/</link>
      <pubDate>Sat, 02 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://yasakura.me/terms/</guid>
      <description>サイトポリシー このサイトポリシー（以下，「本規約」といいます．）は，当ブログ運営者（以下，「運営者」といいます．）がこのウェブサイト上（以下，「当ブログ」といいます．）で提供するコンテンツの利用条件を定めるものです．当ブログを利用することにより，当ブログの利用者（以下，「ユーザー」といいます．）は，本規約に同意したものとみなされます．不同意の意思表示は，本ブログを利用しないことにより認められるものとします．なお，本サイトに掲載されている情報は，予告なく変更される場合があります．
第１条　（適用）  本規約は，当ブログの利用に関わる一切の関係に適用されるものとします． 運営者は当ブログに関し，本規約のほか，ご利用にあたってのルール等，各種の定め（以下，「個別規定」といいます．）をすることがあります．これら個別規定はその名称のいかんに関わらず，本規約の一部を構成するものとします． 本規約の規定が前条の個別規定の規定と矛盾する場合には，個別規定において特段の定めなき限り，個別規定の規定が優先されるものとします．  第２条　（禁止事項） ユーザーは，当ブログの利用にあたり，以下の行為をしてはなりません．
 当ブログの内容等，当ブログに含まれる著作権，商標権ほか知的財産権を侵害する行為 当ブログによって得られた情報を商業的に利用する行為 不正な目的を持って当ブログを利用する行為 当ブログに関連して．反社会的勢力に対して直接または間接に利益を供与する行為 その他，運営者が不適切と判断する行為  第３条　（当ブログの公開の停止など）  運営者は，以下のいずれかの事由があると判断した場合，ユーザーに事前に通知することなく当ブログの全部または一部の公開を停止または中断することができるものとします．  当ブログにかかるコンピュータシステムの保守点検または更新を行う場合 地震，落雷，火災，停電または天災などの不可抗力により，当ブログの公開が困難となった場合 コンピュータまたは通信回線等が事故などにより停止した場合 その他，運営者が当ブログの提供が困難と判断した場合  運営者は，当ブログの公開の停止または中断により，ユーザーまたは第三者が被ったいかなる不利益または損害についても，一切の責任を負わないものとします．  第４条　（保証の否認および免責事項）  運営者は，当ブログに事実上または法律上の庇護（最新性，安全性，信頼性，正確性，完全性，有効性，特定の目的への適合性，セキュリティなどに関する欠陥，エラーやバグ，権利侵害などを含みます．）がないことを明示的にも黙字的にも保証しておりません． 運営者は，当ブログに起因してユーザーに生じたあらゆる損害について一切の責任を負いません． 当ブログに掲載されている情報は，一個人の意見・見解であり，いかなる組織を代表するものではありません．  第５条　（当ブログ内容の変更等） 運営者は，ユーザーに通知することなく，当ブログの内容を変更しまたは当ブログの公開を中止することができるものとし，これによってユーザーに生じた損害について一切の責任を負いません．
第６条　（利用規約の変更） 運営者は，必要と判断した場合には，ユーザーに通知することなくいつでも本規約を変更することができるものとします．その場合は変更後の利用規約が適用されます．
第７条　（知的財産権の保護）  当ブログに掲載されている文章・画像・動画などの著作物の情報や肖像権，商標権，その他知的財産権は，各権利所有者に帰属します．万が一問題がある場合は，運営者までご連絡いただけますと幸いです． ユーザーは，運営者が承認した場合を除き，当ブログを通じて入手したいかなる情報も複写，複製，再発行，アップロード，掲載，転送，配布または二次的著作物作成その他指摘利用の範囲を超えて使用することができないものとします．  第８条　（外部サイトから当ブログへのリンク） 下記の条件に同意の上，リンクを行ってください．リンクに際して，運営者の許諾は不要です．
 当ブログへのリンクであることを明白にすること 運営者からリンクの削除を申し入れた場合には，即座にリンクを中止すること 営利を目的としたものでないこと 当ブログに掲載さている画像や動画に対する直接リンクでないこと 当ブログに社会的・経済的損失が生じないこと 運営者が以下に該当すると判断するウェブサイトからはリンクしない  猥褻・冒涜的な行為・発言などの公序良俗に反する内容を含むウェブサイト 運営者または第三者を誹謗，中傷，脅迫したり，信用を毀損する内容を含むウェブサイト 運営者または第三者の著作権その他財産権を侵害したり，損害，不利益を与える内容を含むウェブサイト その他違法な内容を含むウェブサイト  当ブログへのリンクを許容することは，当ブログの内容に関して保証するものではなく，かつリンクすることによって生じる一切の責任を運営者は一切負いません． リンクは予告無しに変更あるいは削除されることがあります  第９条　（当ブログから外部サイトへのリンク）  当ブログに掲載されている外部サイトは，第三者が運営しているものであり，当ブログの管理するものではありません．第三者のサイトに掲載されている情報の正確性や外部サイトの利用により生じるいかなる損害については，運営者は一切の責任を負いません． リンクされていることは，リンク先と運営者が関係会社，取引先などの関係を有していることを意味しません．  第１０条　（広告の掲載） 運営者は，第三者の広告を当ブログ上に掲載することができるものとします． 第１１条　（アクセス解析ツールの利用） 当ブログは，サイトの利用状況を把握するためにGoogle Analyticsを利用しています．Google Analyticsではトラフィックデータの収集のためにCookieを利用しております．Cookieは個人を特定するものではありません．Google Analyticsで利用されるデータは，Google社のプライバシーポリシーに基づいて管理されます．</description>
    </item>
    
    <item>
      <title>Dockerコンテナのネットワーク構成</title>
      <link>https://yasakura.me/post/docker-network/</link>
      <pubDate>Thu, 13 Aug 2020 00:00:00 +0900</pubDate>
      
      <guid>https://yasakura.me/post/docker-network/</guid>
      <description>モチベーション  Dockerコンテナのネットワークを理解するための足がかりとして，netnsについてまとめたい． Dockerコンテナが構成するネットワークについてまとめたい． -pオプションで何も考えずにポートを外に出すのは危険だよと言いたい  OSI参照モデルで役割を把握しておく OSI参照モデルを覚える必要は無いと思うが，どのレイヤーがどのような役割を行っているのかを理解しておく必要はあると思う．
   レイヤー 呼称 例     L7 アプリケーション層 HTTP,FTP,DNS,SNMP   L6 プレゼンテーション層 HTTP,FTP,DNS,SNMP   L5 セッション層 HTTP,FTP,DNS,SNMP,TCP   L4 トランスポート層 TCP,UDP   L3 インターネット層 IP,ICMP,ARP   L2 リンク層 Ethernet,Wi-Fi   L1 物理層 UTP,STP     L2はブリッジ周辺  Ethernetヘッダの制御．IPパケットに，MACアドレスなどを埋め込んだEthernetヘッダをつける/とる． ブリッジはこの辺．  L3はルーター周辺  IPヘッダの制御．TCPセグメントやICMPセグメントにIPヘッダをつける/とる．  pingやtracerouteはL3で処理される． 経由するルータの数をTTL(Time To Live)として指定することで，TTL=0になるとそのパケットは破棄される．  192.</description>
    </item>
    
    <item>
      <title>Dockerコンテナのライフサイクル</title>
      <link>https://yasakura.me/post/how-to-use-docker/</link>
      <pubDate>Thu, 13 Aug 2020 00:00:00 +0900</pubDate>
      
      <guid>https://yasakura.me/post/how-to-use-docker/</guid>
      <description>モチベーション  Dockerのライフサイクルについてまとめておきたい Dockerfileの書き方についてまとめておきたい docker-composeについてまとめておきたい  Dockerのライフサイクル  docker runで，Dockerイメージを元にコンテナを起動する． docker stopで，コンテナを停止する． docker commitで，停止中のコンテナを新たなDockerイメージとしてとっておく． docker save/loadで，Dockerイメージを持ち運ぶ． docker startで，停止中のコンテナを再開する． docker rmで，停止中のコンテナを破棄する． docker rmiで，Dockerイメージを破棄する．  Dockerイメージを用意する  Dockerfileの書き方
 docker build -t &amp;lt;image name&amp;gt;:&amp;lt;tag&amp;gt; &amp;lt;Dockerfileがあるディレクトリ&amp;gt;によりDockerイメージがつくられる  &amp;lt;tag&amp;gt;にはimageのversionを設定するのが一般的．&amp;lt;tag&amp;gt;を省略した場合はlatestとされる．  docker pull &amp;lt;image name&amp;gt;でDockerイメージをもってくることができる．  DockerイメージはDocker Hubにて検索できる．  docker imagesで手元にあるDockerイメージ一覧を表示する．  docker images -qにより，DockerイメージID一覧を表示する．   Dockerイメージを元に，コンテナを立ち上げる  docker run -it --name &amp;lt;container name&amp;gt; &amp;lt;image name&amp;gt;:&amp;lt;tag&amp;gt; &amp;lt;command&amp;gt;  &amp;lt;image name&amp;gt;:&amp;lt;tag&amp;gt;から&amp;lt;container name&amp;gt;という名前のコンテナを立ち上げ，コンテナ内で&amp;lt;command&amp;gt;を実行する． -iはホストからコンテナへの標準入力を繋げるためのもの．-tはコンテナからホストへの標準出力を繋げるためのもの． -hオプションによって，ホスト名を指定できる． -dオプションによって，コンテナをバックグラウンドで実行できる． -p &amp;lt;host&amp;gt;:&amp;lt;container&amp;gt;オプションによって，ホストのポートとコンテナのポートをつなげる．この時，iptablesが書き換えられ，ホスト側のポートがWANに曝されるので注意．  -pでなく，--expose &amp;lt;port&amp;gt;フラグを指定すると，リンクしたコンテナから&amp;lt;container name&amp;gt;:&amp;lt;exposed port&amp;gt;でアクセスすることができる．また，iptablesは変更されない．  --rmフラグによって，コンテナがstopしたあとはコンテナを削除するようにする． --privilegedフラグによって，コンテナ内からホストのデバイスにアクセスすることができる．セキュリティには注意する．  --deviceフラグや--cap-addフラグによってデバイス単位で細かくアクセス権限を制御することができる．  --link &amp;lt;container&amp;gt;:&amp;lt;nickname&amp;gt;を指定することで，&amp;lt;container&amp;gt;へアクセスする際のホスト名として利用できる．  例えば，hogeという名前のコンテナが立ち上がっている環境で，--link hoge:hgを指定して新たなコンテナを立ち上げたとすると，そのコンテナからはcurl http://hogeというような形でアクセスすることができる．  Dockerイメージによっては，ずっと起動するものもあれば，&amp;lt;command&amp;gt;を一発実行してstopするものもある．  &amp;lt;command&amp;gt;に/bin/shを指定し，コンテナ内にshを立ち上げることで，コンテナを立ち上げたままにしておくことが多い．   docker ps  起動中のコンテナ一覧を表示する  docker attach &amp;lt;container&amp;gt;  コンテナにアタッチする．アタッチ後の振る舞いはDockerイメージによって異なり，コンテナの標準入出力が可能になる場合もあれば，何も起きない場合もある． アタッチしている状態で，ctrl+pしctrl+qすると，コンテナからデタッチすることができる．  docker exec -it &amp;lt;container&amp;gt; &amp;lt;command&amp;gt;  起動中のコンテナにコマンドを流し込むことができる． &amp;lt;command&amp;gt;に/bin/shを指定してコンテナ内にシェルを立ち上げることで，コンテナ内で作業することができる．   DockerコンテナのPID=1問題 docker runで指定した&amp;lt;commnad&amp;gt;は，PID=1のプロセスとして実行される．PID=1なプロセスはカーネルから特別扱いされるため，プロセス自体がシグナルをハンドルするように実装されていなければ，シグナルは無視されてしまう．</description>
    </item>
    
    <item>
      <title>Gitをやっていく</title>
      <link>https://yasakura.me/post/how-to-use-git/</link>
      <pubDate>Thu, 13 Aug 2020 00:00:00 +0900</pubDate>
      
      <guid>https://yasakura.me/post/how-to-use-git/</guid>
      <description>モチベーション  個人的に普段よく使うGitコマンドについて自分なりにまとめておきたい Pro Gitだとカロリー過多  Repositoryを用意する Local Repositoryから始める  git init &amp;lt;directory&amp;gt;  &amp;lt;directory&amp;gt;をLocal repositoryとする． &amp;lt;directory&amp;gt;内に.gitという隠しフォルダが作成される．Gitの諸々は.gitで管理されることになる．   Remote Repositoryから始める  GitHubにSSH公開鍵を登録しておく
 cd ~/.ssh ssh-keygen -t rsa -b 4096で鍵作成 chmod 600 &amp;lt;秘密鍵へのパス&amp;gt; パスフレーズを設定したなら  ssh-add &amp;lt;秘密鍵へのパス&amp;gt;で秘密鍵をSSHエージェントに登録 ssh-add -lでSSHエージェントに秘密鍵が登録されたことを確認  pbcopy &amp;lt; &amp;lt;公開鍵へのパス&amp;gt;で公開鍵をクリップボードにコピー SSH and GPG keysのNew SSH keyに公開鍵をコピペ ~/.ssh/configに接続先を登録
Host &amp;lt;nickname&amp;gt; HostName github.com IdentityFile &amp;lt;秘密鍵へのパス&amp;gt; User git  ssh -T &amp;lt;nickname&amp;gt;で接続確認
 Hi XXX! You&#39;ve successfully authenticated, but GitHub does not provide shell access.</description>
    </item>
    
    <item>
      <title>UbuntuにNginxコンテナを立ててHTTPSに対応する</title>
      <link>https://yasakura.me/post/ubuntu-nginx-docker-letsencrypt/</link>
      <pubDate>Thu, 13 Aug 2020 00:00:00 +0900</pubDate>
      
      <guid>https://yasakura.me/post/ubuntu-nginx-docker-letsencrypt/</guid>
      <description>モチベーション  まっさらなUbuntuにNginxコンテナを立てて，それをWEBサーバーとして運用したい． Let&amp;rsquo;s encryptでHTTPSに対応したい．  前準備  UbuntuがインストールされたAmazon EC2やAmazon Lightsail，GCP Compute Engine, VPSや物理サーバなどを用意し，グローバルなIPアドレスを設定しておく． ドメインを取得し，UbuntuサーバーのIPアドレスと関連付けておく．  パッケージをアップデートする  apt updateでパッケージ一覧を更新 apt upgradeでパッケージを更新 apt autoremoveで必要なくなったパッケージを削除 apt autocleanで.debファイルを削除
 /var/log/apt/history.logにaptコマンドの履歴がある /var/log/apt/term.logにaptコマンドのログがある   パッケージの自動アップデートを設定する セキュリティ対策のため，パッケージは常に最新になるようにする．
 20-auto-upgradesを編集する
vi /etc/apt/apt.conf.d/20auto-upgrades
APT::Periodic::Update-Package-Lists &amp;quot;1&amp;quot;; APT::Periodic::Download-Upgradeable-Packages &amp;quot;1&amp;quot;; APT::Periodic::AutocleanInterval &amp;quot;7&amp;quot;; APT::Periodic::Unattended-Upgrade &amp;quot;1&amp;quot;;   Update-Package-Lists : アップデートの確認頻度[Day] Download-Upgradeable-Packages : アップデートをダウンロードしておくか AutocleanInterval : クリーンアップ頻度[Day] Unattended-Upgrade : アップデートをインストールするか  50unattended-upgradesを編集する
vi /etc/apt/apt.conf.d/50unattended-upgrades
&amp;quot;${distro_id}:${distro_codename}-updates&amp;quot;; をコメントアウト  20-auto-upgradesを適用する
dpkg-reconfigure -plow unattended-upgrades</description>
    </item>
    
    <item>
      <title>関数の最大値または最小値を機械的に求める</title>
      <link>https://yasakura.me/post/how-to-solve-numerical-min-max/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:05 +0900</pubDate>
      
      <guid>https://yasakura.me/post/how-to-solve-numerical-min-max/</guid>
      <description>おことわり 勉強中のため随時更新中です
モチベーション 関数の最大値または最小値を機械的に求めるためにはどうしたらよいかを知る
シュワルツの不等式 $$ |\boldsymbol{x}^T\boldsymbol{y}| \leq \|\boldsymbol{x}\| \|\boldsymbol{y} \| $$  $\boldsymbol{x}$ と $\boldsymbol{y}$ が1次従属となる場合に等号が成立する．これは，内積 $\vec{a} \cdot \vec{b} = |\vec{a}| |\vec{b}| \cos \theta$ をイメージするとわかりやすい．
Rolleの定理 rolle theorem $f(x)$ が $[a,b]$ で連続， $(a,b)$ で微分可能， $f(a)=f(b)$ を満たすとき， $f&amp;rsquo;(c) = 0$ となる $a &amp;lt; c &amp;lt; b$ が存在する．
平均値の定理 mean-value theorem $f(x)$ が $[a,b]$ で連続， $(a,b)$ で微分可能なとき， $\frac{f(b)-f(a)}{b-a} = f&amp;rsquo;(c)$ となる $a &amp;lt; c &amp;lt; b$ が存在する．
テイラーの定理による関数の近似 1階微分可能な関数の近似（ラグランジュの剰余項） 関数 $f:\mathbb{ R }^n \to \mathbb{R}$ が１階微分可能のとき， $\boldsymbol{x_0,\delta} \in \mathbb{R}$ に対して実数 $c \in (0,1)$ が存在する．</description>
    </item>
    
    <item>
      <title>劣微分とLassoによるスパース性</title>
      <link>https://yasakura.me/post/subdifferential/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:04 +0900</pubDate>
      
      <guid>https://yasakura.me/post/subdifferential/</guid>
      <description>モチベーション  部分的に微分できない関数をなんとか微分したい L1正則化(Lasso)を用いると，過学習を防げる場合がある  関数の種類 目的関数の最小値を求めたい機会は多々ある，目的関数を微分することで最小値を求めることがあるが，関数の形によっては，部分的に微分できない場合がある．例えば， $y=\|x\|$ は $x=0$ で微分不可能である．
 関数が連続でない：境界（ $y=\|x\|$ の $x=0$ 付近）において，左極限と右極限が一致しないもの $C_1$ 級関数：1階微分可能であり，それが連続であるもの $C_n$ 級関数：n階微分可能であり，n階の導関数が連続であるもの 滑らかな関数：任意階微分可能であり，任意階の導関数が連続であるもの．$C_\infty$ 級関数．  劣微分・劣勾配 凸関数を最小化するために勾配情報が欲しいが，凸関数はいつでも微分可能であるとは限らない．例えば， $y=|x|$ は凸関数だが， $x=0$ で微分可能でない．このような関数に対して勾配（劣勾配）を定義してみる．
真凸関数 $f:\mathbb{R}^n \to \mathbb{R} \cup \{\infty\}$ かつ $x \in dom(f)$ の元で， $\forall y \in \mathbb{R}^n$ が
$$ f(\boldsymbol{y}) \geq f(\boldsymbol{x}) + \boldsymbol{g}^{\mathrm{T}}(\boldsymbol{y}-\boldsymbol{x}) $$  を満たすとき， $\boldsymbol{g}$ を $\boldsymbol{x}$ における劣勾配という．劣勾配の集合 $\partial f(\boldsymbol{x})$ を劣微分という．
$f(x)=|x|$ の $x=0$ における劣微分は，以下より， $\partial f(0) = [-1,1]$ と求まる．</description>
    </item>
    
    <item>
      <title>線形モデルでデータを表現する</title>
      <link>https://yasakura.me/post/linear-model/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:04 +0900</pubDate>
      
      <guid>https://yasakura.me/post/linear-model/</guid>
      <description>モチベーション 散布図から関数を予測したい
scikit-learnのLinearRegressionで単回帰する -3 &amp;lt; x &amp;lt; 3 の範囲でxをランダムに50点生成し， $y=0.1x+0.3$ に入力した後，yにσ=0.1のガウシアンノイズを加えたtを教師データとした．青線(original)が直線y，散布図(training data)がtである．
scikit-learnのLinearRegressionを用いて $y=0.1x+0.3$ を予測したものが赤線 (predictive) である．
coefficientは0.09くらい，interceptは0.30くらいとなり， $y=0.09x+0.30$ と予測できた．
import numpy as np from matplotlib import pyplot as plt from sklearn.linear_model import LinearRegression from sklearn.model_selection import train_test_split from matplotlib.colors import ListedColormap colors = [&amp;#39;#e74c3c&amp;#39;, &amp;#39;#3498db&amp;#39;, &amp;#39;#1abc9c&amp;#39;, &amp;#39;#9b59b6&amp;#39;, &amp;#39;#f1c40f&amp;#39;] # red, blue, green, purple, yellow cmap = ListedColormap(colors) plt.style.use(&amp;#39;seaborn&amp;#39;) def f(x): return 0.1*x + 0.3 N = 50 X = np.</description>
    </item>
    
    <item>
      <title>決定木で分類と回帰を行う</title>
      <link>https://yasakura.me/post/classification-and-regression-with-decision-tree/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:03 +0900</pubDate>
      
      <guid>https://yasakura.me/post/classification-and-regression-with-decision-tree/</guid>
      <description>モチベーション  決定木で分類と回帰をやりたい なぜ決定木で分類と回帰ができるのかを知りたい scikit-learnでサクッとやりたい  scikit-learnのDecisionTreeClassifierで分類する 2つの特徴量 $X_0,X_1$ からなる，以下のようなデータセットを分類したい．
from sklearn.datasets import make_moons import matplotlib.pyplot as plt from matplotlib.colors import ListedColormap # style colors = [&amp;#39;#e74c3c&amp;#39;, &amp;#39;#3498db&amp;#39;, &amp;#39;#1abc9c&amp;#39;, &amp;#39;#9b59b6&amp;#39;, &amp;#39;#f1c40f&amp;#39;] # red, blue, green, purple, yellow cmap = ListedColormap(colors) plt.style.use(&amp;#39;seaborn&amp;#39;) X, y = make_moons(n_samples=100, noise=0.25, random_state=0) plt.figure(figsize=(4,4)) plt.scatter(X[:,0], X[:,1], c=y, cmap=cmap, marker=&amp;#39;.&amp;#39;) plt.ylabel(&amp;#39;X0&amp;#39;) plt.xlabel(&amp;#39;X1&amp;#39;) plt.show() scikit-learnのDecisionTreeClassifierで分類した結果が以下である．
 1.10. Decision Trees Users Guide sklearn.tree.DecisionTreeClassifier  from sklearn.datasets import make_moons from matplotlib.</description>
    </item>
    
    <item>
      <title>対角化の恩恵を授かる</title>
      <link>https://yasakura.me/post/diagonalization/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:02 +0900</pubDate>
      
      <guid>https://yasakura.me/post/diagonalization/</guid>
      <description>モチベーション  行列を用いた座標変換をおさらいしたい 対角化で行列計算を楽にしたい  線形独立と線形従属 線形独立と線形従属 is 何？ 列ベクトル $\boldsymbol{e}_k (k=1,2,\dots,n)$を$\forall l_j \in \mathbb {R} (j=1,2,\dots,m)$ を用いて以下のようにおいてみる．つまり， $\boldsymbol{e}_k \in \mathbb {R}^m$ ．
$$ \boldsymbol{e}_k= \begin{pmatrix} l_{1k}\\ l_{2k}\\ \vdots\\ l_{mk} \end{pmatrix} $$  次に，列ベクトル集合 $\lbrace \boldsymbol{e_1}, \boldsymbol{e_2}, \dots, \boldsymbol{e_n} \rbrace$と$\forall a_k \in \mathbb {R} (k=1,2,\dots,n)$ を用いて，以下のような線形和をつくる．
$$ a_1\boldsymbol{e_1}+a_2\boldsymbol{e_2}+\dots+a_n\boldsymbol{e_n}　\tag{1} $$  (1)式を0にできるような， $a_k$ が複数あるなら， $\lbrace \boldsymbol{e_1}, \boldsymbol{e_2}, \dots, \boldsymbol{e_n} \rbrace$ は線形従属であると言う．ベクトルをうまく組み合わせれば，一つの輪をつくることができるイメージ．
一方，(1)式を0にするには $a_k=0 (k=1,2,\dots,n)$ が必要である場合， $\lbrace \boldsymbol{e_1}, \boldsymbol{e_2}, \dots, \boldsymbol{e_n} \rbrace$ は線形独立であると言う．つまり，ベクトルを組み合わせても輪がつくれないイメージ．</description>
    </item>
    
    <item>
      <title>Python2.XとPython3.Xを共存させる</title>
      <link>https://yasakura.me/post/manage-python3-and-python27/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:01 +0900</pubDate>
      
      <guid>https://yasakura.me/post/manage-python3-and-python27/</guid>
      <description>モチベーション  Python2.X系とPython3.X系やpipとpip3を共存させて，必要に応じて切り替えて使いたい． Pythonのマイナーバージョンを細かく切り替えたい． pipでパッケージをインストールすると環境が汚れてしまうのでプロジェクトごとにパッケージを管理したい． 「プロジェクトごとにDockerコンテナを立ち上げてそこでPythonを実行する」というような大げさな管理はしたくない．  pyenvでPythonのバージョンを切り替える  デフォルトのPythonのバージョンを確認する
$ python --version Python 2.7.16 brewでpyenvをインストールする
$ brew install pyenv PATHなどを設定する
export PYENV_ROOT=&amp;#34;${HOME}/.pyenv&amp;#34; export PATH=${PYENV_ROOT}/bin:$PATH eval &amp;#34;$(pyenv init -)&amp;#34; pyenvで使用可能なPythonのバージョン一覧を確認する
$ pyenv install -l Available versions: 2.1.3 2.2.3 2.3.7 : : 任意のバージョンをインストールする
$ pyenv install 3.9.0 : Installed Python-3.9.0 to /Users/xxxx/.pyenv/versions/3.9.0 切替可能なバージョンを確認する
$ pyenv versions \* system (set by /Users/xxxx/.pyenv/version) 3.9.0  システム全体のPythonバージョンを切り替える $ pyenv global 3.9.0 $ pyenv versions system \* 3.</description>
    </item>
    
    <item>
      <title>Hugoで静的サイトをジェネる</title>
      <link>https://yasakura.me/post/generate-static-site-with-hugo/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0900</pubDate>
      
      <guid>https://yasakura.me/post/generate-static-site-with-hugo/</guid>
      <description>モチベーション  ブログを書きたい デザインを自由にカスタマイズしたい WordPressなどのCMSで管理するほどでもない StaticGenの上位にHugoがある  記事を新規作成する $ hugo new post/&amp;lt;article name&amp;gt;.md  プロジェクトディレクトリにあるarchetypes/のdefault.mdを元に新しいエントリがcontent/以下に作成される．  リアルタイムでプレビューしながら記事を執筆orテーマをカスタマイズする $ hugo server --watch -D --port &amp;lt;port&amp;gt; --bind 0.0.0.0 --baseURL=&amp;lt;local machine&amp;#39;s IP address&amp;gt;  コードを変更するごとに自動でリロードさせるためには，--watchをつける．
 Draft記事を表示させるためには，-Dをつける．
 --bindを指定しない場合は，127.0.0.1にbindされる．127.0.0.1へのbindだと，hugo serverを実行しているローカルマシンからのアクセスhttp://localhost:&amp;lt;port&amp;gt;のみに制限されてしまう．0.0.0.0にbindすることで，LAN内にあるローカルマシン以外（スマホなど）からはhttp://&amp;lt;local machine&#39;s IP address&amp;gt;:&amp;lt;port&amp;gt;でアクセスできるようになる．  Themeのカスタマイズ ユーザが指定したパラメータを呼び出す  .Params.xxxはarticleのfront-matterから参照される
 .Site.Params.xxxはconfig.tomlから参照される  リストコンテンツの順番を制御できるページネーションを実装する {{ $v1 := where .Pages &amp;#34;.Params.type&amp;#34; &amp;#34;!=&amp;#34; &amp;#34;about&amp;#34; }} {{ $v2 := where .Pages &amp;#34;.Params.type&amp;#34; &amp;#34;!=&amp;#34; &amp;#34;terms&amp;#34; }} {{ $pages := $v1 | intersect $v2 }} {{ $paginator := .</description>
    </item>
    
    <item>
      <title>ABOUT ME</title>
      <link>https://yasakura.me/about/</link>
      <pubDate>Sat, 28 Mar 2020 00:00:00 +0900</pubDate>
      
      <guid>https://yasakura.me/about/</guid>
      <description>I&amp;rsquo;m Software Developer.
For further inquiries, please feel free to contact @yasakurara.
Skills and Experiences  Web front-end and back-end  Linux (CentOS, Ubuntu, Red Hat Enterprise Linux) PHP (Laravel, WordPress) HTML, CSS, JavaScript (Node.js, Vue.js) Database (MongoDB, MySQL) Docker  Embedded hardware and software  PIC microcontrollers, PICkit, MPLAB FPGA, HDL (Verilog) Serial Communication (UART, USART, I2C) SuperH, HEW Linux cross-compile (Buildroot), Kernel Driver Realtime OS (μITRON) Single-board Computer (Raspberry Pi, Intel Edison, Arduino, Beagle Board&amp;hellip;) C, C++  Satellite Development  Onboard computer and software Spacecraft communications and Ground System (CCSDS) Flight software and hardware verification (i.</description>
    </item>
    
  </channel>
</rss>